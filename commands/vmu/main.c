/* DreamShell ##version##

   vmu.c
   Copyright (C) 2009-2014 SWAT
*/

#include "ds.h"


static uint16 DS_pal[16] = {
	0xF303,0xF975,0xFFB5,0xF244,0xF653,0xFC95,0xFCC6,0xF964,
	0xFA95,0xF533,0xF465,0xF222,0xFFA5,0xF443,0xFFD6,0xF764
}; 
static uint8 DS_data[32*32/2] = {
	0x2C,0x22,0x22,0x22,0x22,0xE2,0xEE,0xEE,0xE2,0x22,0xE2,0x22,0xCC,0x51,0x74,0xDD,
	0x22,0x22,0x22,0x22,0x22,0xEE,0x2E,0xEE,0xEE,0xEE,0x22,0x22,0x2C,0xCC,0x17,0xFF,
	0x2E,0x22,0x22,0x22,0x22,0x22,0xEE,0xEE,0xEE,0xE2,0xE2,0x22,0xC2,0xCC,0xC5,0x14,
	0xEE,0x22,0xC2,0x22,0x22,0x2E,0xEE,0xEE,0xEE,0xEE,0xE2,0x22,0x22,0x22,0xCC,0x51,
	0xE2,0x2E,0xEE,0xE2,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xE2,0x22,0x22,0x22,0x2C,0xC5,
	0xE2,0xEE,0x28,0x82,0xE2,0xEE,0x2E,0xEE,0xEE,0xEE,0xE2,0x22,0x22,0x2E,0x22,0xCC,
	0xEE,0x2E,0x8B,0x3D,0x1C,0x2E,0xEE,0xEE,0xEE,0xEE,0xE6,0x81,0xF8,0x52,0x22,0x2C,
	0xE2,0x2E,0x43,0x33,0xB3,0x45,0xEE,0xEE,0xEE,0xEE,0x8A,0xA3,0x3A,0x3A,0x5E,0x2C,
	0x22,0x22,0x43,0x33,0x33,0x33,0x8E,0xEE,0xEE,0xE8,0xAA,0x3F,0xFA,0xAA,0xC2,0x22,
	0x22,0x22,0x73,0xAC,0x1D,0xB3,0x3F,0xEE,0xEE,0x6A,0xAF,0x62,0xE2,0x52,0x22,0x22,
	0x2C,0xC2,0xFB,0xA2,0x22,0x73,0x33,0x1E,0xEE,0x8A,0xA6,0xEE,0xEE,0x22,0x22,0x22,
	0xCC,0xCC,0xF3,0xA2,0xC2,0x2C,0xD3,0xA6,0xEE,0x1A,0xA1,0x88,0x88,0x2E,0x22,0x22,
	0xCC,0xCC,0x73,0x4C,0xCC,0xCC,0x53,0x31,0xEE,0x2A,0xAA,0xAA,0xAA,0xA8,0xE2,0x22,
	0xCC,0x5C,0x43,0xA5,0xC5,0x5C,0xCF,0x3A,0xEE,0xE2,0x81,0xFF,0xAA,0xAA,0x1E,0x22,
	0xC5,0xC5,0x43,0xA5,0x55,0x5C,0xC4,0xAA,0x2E,0xEE,0xE2,0xEE,0xE5,0xFA,0xA2,0x22,
	0xC5,0x55,0x4B,0xA1,0x15,0x55,0x5A,0x3A,0xEE,0x22,0xE2,0xE2,0xEE,0x8A,0x35,0x25,
	0x55,0x15,0xD3,0xA7,0x57,0x55,0x13,0x38,0xE1,0xA8,0x22,0xE2,0xEC,0xA3,0xDC,0xC5,
	0x11,0x17,0xD3,0xAF,0x18,0x11,0x33,0xA2,0x2A,0x33,0x15,0xC8,0x1A,0x33,0x4C,0x51,
	0x11,0x77,0xDB,0x33,0x33,0x3B,0x33,0x82,0x2F,0x33,0x33,0xB3,0xB3,0x3D,0x51,0x77,
	0x77,0x7F,0x4B,0xBB,0xBB,0xBB,0xD8,0x22,0x22,0x4B,0xBB,0xBB,0xB9,0x77,0x77,0x44,
	0x77,0x44,0xD4,0xDD,0xBD,0xDF,0x55,0x65,0x22,0xCC,0x77,0x77,0x17,0x77,0xF4,0x44,
	0xF4,0xD4,0x44,0xD4,0xF7,0x15,0x55,0x25,0x65,0x55,0x57,0x81,0x79,0x49,0x9D,0xDD,
	0x44,0x44,0x44,0x44,0x41,0x18,0x85,0x85,0x55,0x55,0x19,0x44,0xB9,0xBB,0xB9,0xDD,
	0xF4,0xD4,0xD4,0x44,0xFF,0x88,0x88,0x85,0x55,0x58,0x17,0x90,0x4F,0x9B,0x9D,0xDB,
	0x44,0x44,0x44,0x4A,0x11,0x11,0x88,0x88,0x88,0x88,0x17,0xBB,0x44,0xDB,0xBD,0x9B,
	0xF4,0x44,0x44,0xAF,0x1F,0x11,0x81,0x88,0x88,0x81,0x79,0xDD,0xBD,0xDB,0x9D,0xBD,
	0x74,0x44,0x4A,0xFA,0x11,0x1F,0x11,0x11,0x81,0x81,0x1D,0xFF,0x9D,0x4B,0x9D,0xDD,
	0x17,0x74,0x4F,0xFF,0xFF,0x11,0x11,0x11,0x11,0x11,0xF1,0x44,0x4D,0xD4,0x44,0x44,
	0xC1,0xFF,0x41,0xF1,0xFF,0xFF,0xFF,0x11,0x11,0x11,0x17,0x44,0x74,0x44,0x44,0x4D,
	0xCC,0x17,0x71,0xFF,0xFF,0xFA,0xFF,0xFF,0x1F,0x18,0x11,0x1F,0x4F,0x4D,0xDD,0xDB,
	0xCC,0xC5,0x1F,0x1F,0xFF,0xFF,0xAA,0x4A,0xFA,0xFF,0xFF,0x4A,0x4D,0xDD,0xB9,0xBB,
	0xCC,0x2C,0x51,0x11,0xFF,0xFF,0xFF,0xAA,0x4A,0xA4,0xAA,0x3D,0xDB,0x3B,0xBB,0xBB
};


int main(int argc, char *argv[]) { 

	if(argc < 2) {
		ds_printf("Usage: %s option args...\n\n"
				"Options: \n"
				" -c, --convert      -Convert file\n"
				" -d, --dump         -Dump VMU\n", argv[0]);
		ds_printf(" -r, --restore      -Restore dump\n"
				" -s, --size         -Set VMU size(in blocks)\n"
				" -p, --printinfo    -Print VMU info\n\n");
		ds_printf("Arguments: \n"
				" -a, --address      -VMU address\n"
				" -n, --normal       -Convert to normal file\n"
				" -v, --vmu          -Convert to VMU file\n");
		ds_printf(" -i, --info         -VMU file description\n"
				" -f, --file         -In file\n"
				" -o, --out          -Out file\n\n");
		ds_printf("Examples: %s -c -v -f /cd/file.txt -o /vmu/a1/DSFILE00.DSV -i Test vmu file\n"
				"          %s --convert --normal --file /vmu/a1/DSFILE00.DSV --out /ram/file.txt\n"
				"          %s -d -a A1 -o /ram/dump.vmd\n"
				"          %s --restore --address A1 --file /ram/dump.vmd\n"
				"          %s -p -s 240\n", argv[0], argv[0], argv[0], argv[0], argv[0]);
		return CMD_NO_ARG;
	}

	int port, unit, i, siz;
	maple_device_t *dev = NULL;
	uint8 *vmdata;

	file_t f;
	file_t fd;

	int convert = 0, dump = 0, restore = 0, normal = 0, vmu = 0, printinf = 0;
	int vmsize = 0;
	char *file = NULL, *out = NULL, *addr = NULL, **preinfo = NULL;

	struct cfg_option options[] = {
		{"convert",   'c', NULL, CFG_BOOL, (void *) &convert,  0},
		{"dump",      'd', NULL, CFG_BOOL, (void *) &dump,     0},
		{"restore",   'r', NULL, CFG_BOOL, (void *) &restore,  0},
		{"printinfo", 'p', NULL, CFG_BOOL, (void *) &printinf, 0},
		{"size",      's', NULL, CFG_INT,  (void *) &vmsize,   0},
		{"address",   'a', NULL, CFG_STR,  (void *) &addr,     0},
		{"normal",    'n', NULL, CFG_BOOL, (void *) &normal,   0},
		{"vmu",       'v', NULL, CFG_BOOL, (void *) &normal,   0},
		{"info",      'i', NULL, CFG_STR+CFG_MULTI+CFG_LEFTOVER_ARGS, (void *) &preinfo, 0},
		{"file",      'f', NULL, CFG_STR,  (void *) &file,     0},
		{"out",       'o', NULL, CFG_STR,  (void *) &out,      0},
		CFG_END_OF_LIST
	};

	CMD_DEFAULT_ARGS_PARSER(options);

	if(dump || restore || vmsize > 0) {
		 
		if(addr == NULL) {
			ds_printf("DS_ERROR: Too few arguments. (VMU address)\n");
			return CMD_NO_ARG; 
		}

		port = addr[0] - 'A';
		unit = addr[1] - '0';
		dev = maple_enum_dev(port, unit);

		if (!dev || !(dev->info.functions & MAPLE_FUNC_MEMCARD)) {
			ds_printf("DS_ERROR: No device, or device not a VMU\n");
			return CMD_ERROR;
		}
	}

	if(printinf || vmsize > 0) {
		
		vmu_root_t vmroot;
		memset(&vmroot, 0, sizeof(vmu_root_t));
		vmufs_root_read(dev, &vmroot);

		if(printinf) {
			ds_printf("\n    VMU (%s) Info: \n\n"
					" Type: %s\n"
					" FAT location: %d\n"
					" FAT size in blocks: %d\n"
					" Directory location: %d\n"
					" Directory size in blocks: %d\n"
					" Icon shape for this VMS: %d\n"
					" Number of user blocks: %d\n", addr, vmroot.use_custom ? "custom" : "standard",
					vmroot.fat_loc, vmroot.fat_size, vmroot.dir_loc, 
					vmroot.dir_size, vmroot.icon_shape, vmroot.blk_cnt);
		}

		if(vmsize > 0) {
			ds_printf("%sDS_PROCESS: Current size %d blocks, set to %d blocks...\n", 
					printinf ? "\n" : "", (int)vmroot.blk_cnt, vmsize);
			vmroot.blk_cnt = (uint16)vmsize;
			vmufs_root_write(dev, &vmroot);
		}
	}

	if(dump) {

		if(out == NULL) {
			ds_printf("DS_ERROR: Too few arguments. (out file)\n");
			return CMD_NO_ARG; 
		}

		f = fs_open(out, O_WRONLY | O_CREAT | O_TRUNC);

		if(f < 0) {
			ds_printf("DS_ERROR: Can't open %s", out);
			return CMD_ERROR;
		}

		vmdata = (uint8 *) malloc(512);
		memset(vmdata, 0, 512);

		ds_printf("DS_PROCESS: %s dumping...\n", addr);

		for (i = 0; i < 256; i++) {
			if (vmu_block_read(dev, i, vmdata) < 0) {
				ds_printf("DS_ERROR: Failed to read block %d\n", i);
				fs_close(f);
				free(vmdata);
				return CMD_ERROR;
			}
			fs_write(f, vmdata, 512);
		}

		fs_close(f);
		free(vmdata);
		ds_printf("DS_OK: Dumping complete.\n"); 
		return CMD_OK;
	}

	
	if(restore) {

		if(file == NULL) {
			ds_printf("DS_ERROR: Too few arguments. (file)\n");
			return CMD_NO_ARG; 
		}

		f = fs_open(file, O_RDONLY);

		if(f < 0) {
			ds_printf("DS_ERROR: Can't open %s", file);
			return CMD_ERROR; 
		}

		vmdata = (uint8 *) malloc(512);
		memset(vmdata, 0, 512);

		i = 0; 
		ds_printf("DS_PROCESS: Restore %s to %s...\n", file, addr);

		while((siz = fs_read(f, vmdata, 512)) > 0) {
			if(vmu_block_write(dev, i, vmdata) < 0) {
				ds_printf("DS_ERROR: Failed to write block %d\n", i);
				fs_close(f);
				free(vmdata);
				return CMD_ERROR;
			}
			i++;
		}

		fs_close(f);
		free(vmdata);
		ds_printf("DS_OK: Restore complete.\n");
		return CMD_OK;
	}

	if(convert) {

		uint8 *pkg_out;
		vmu_pkg_t pkg;
		int pkg_size;
		char info[32];

		if(out == NULL || file == NULL) {
			ds_printf("DS_ERROR: Too few arguments. \n");
			return CMD_NO_ARG;
		}

		f = fs_open(file, O_RDONLY);

		if(f < 0) {
			ds_printf("DS_ERROR: Can't open %s\n", file);
			return CMD_ERROR;
		} 

		fd = fs_open(out, O_CREAT | O_WRONLY);

		if(fd < 0) {
			ds_printf("DS_ERROR: Can't open %s\n", out);
			return CMD_ERROR;
		} 

		siz = fs_total(f); 
		vmdata = (uint8 *) malloc(siz); 
		fs_read(f, vmdata, siz); 
		fs_close(f); 

		if(vmu) {

			ds_printf("DS_PROCESS: Convert %s to VMU file...\n", file);
			strcpy(pkg.desc_short, "DreamShell File");
			memset(info, 0, sizeof(info));

			if(preinfo == NULL) {

				strcpy(pkg.desc_long, "No description");

			} else {

				strcpy(info, preinfo[0]);
				strcat(info, " ");

				for(i = 1; preinfo[i]; i++) {
					strcat(info, preinfo[i]);
					strcat(info, " ");
				}

				strcpy(pkg.desc_long, info);
			}

			strcpy(pkg.app_id, "DreamShell File");
			pkg.icon_cnt = 1;
			pkg.icon_anim_speed = 0;
			memcpy(pkg.icon_pal, DS_pal, 32);
			pkg.icon_data = DS_data;
			pkg.eyecatch_type = VMUPKG_EC_16BIT; //VMUPKG_EC_NONE;
			pkg.data_len = siz;
			pkg.data = vmdata;

			vmu_pkg_build(&pkg, &pkg_out, &pkg_size);
			fs_unlink(out);
			fs_write(fd, pkg_out, pkg_size);
			fs_close(fd);

			free(vmdata);
			free(pkg_out);
			return CMD_OK;
		} 

		if(normal) { 

			ds_printf("DS_PROCESS: Convert %s to normal file...\n", file);
			vmu_pkg_parse(vmdata, &pkg);
			fs_write(fd, pkg.data, pkg.data_len);
			fs_close(fd);
			free(vmdata);
			return CMD_OK;
		}

		ds_printf("DS_ERROR: Too few arguments. (convert to?)\n");
		return CMD_OK;
	}

	if(!printinf || vmsize == 0) {
		ds_printf("DS_ERROR: There is no option.\n");
	}

	return CMD_OK;
}
